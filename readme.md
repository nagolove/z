`zero` - язык программирования транслируемый в C.

Тезисы:
* скорость компиляции
* шаблонные функции
* возможно raii или что-то для управления памятью
* встроенный LSP?
* встроенная поддержка интроспекции и системы дополнения.
* "квадратные типы" 
    - int8
    - int16
    - int32
    - int64
    - int128
    - float
* все конструкции являются выражениями, то есть возвращают значения
* небольшое или минимальное количество "ключевых" слов
* справка по функциям
* как агррегировать данные?
    Применение структур аналогичных C.
* строгость в именовании переменных и функций(Rust, Haskell) или позволять свободный стиль?
    Первоначально свободный стиль.
* доступ к отдельным битам
    Реализовать как библиотечные функции?

Насколько в z программа может быть с неопределенным поведением?
Что если отталкиваться непосредственно от C?

Сделать одну вещь одним способом.
Сделать одну вещь несколькими способами.
Баланс между этими максимами - сделать одну вещь не более чем двумя(тремя)
способами.

Пространства имен

Ключевые слова, управляющие конструкции:
```
    type, 
    use,    # include, import, using
    struct, (record?)
    for, if, while, do, loop
    function(?)
    template
    match
    enum
    attr
    void
    fn
```
Что делать с объектно-ориентированным подходом?
Подход C++ - структура, указатель на "это", таблица виртуальных функций?

Какие контейнеры доступны в стандартной библиотеке? 
Первоначально никаких контейнеров недоступно. Дополнять контейнеры при 
переписывании транспилера с Lua на z.

Отдавать преимущество созданию чистых функций. Устройство maybe.
Передача аргументов по ссылке или по указателю?
Безопасность работы с памятью отсутствует, возможно писать куда угодно.
Управление памятью аналогично умным указателям C++, основано на механизме
макросов.

Первоначальная реализация кодогенератора - на Lua.

Ознакомиться с языками:
* factor (стековый)
* V (транспилер в C)
* go (сборка мусора, многопоточная работа)

В рамках ознакомления структурированно записать впечатления.

Система сборки встроенная в компилятор? Промежуточный формат хранения 
объектных файлов(модулей?). Параллельность компиляции нескольких файлов до 
возникновения ошибки и ожидание готовности соответствующего модуля.

Примеры ошибок на C:

    // Как до разрешения бага можно было додуматься раньше?
    // В функцию передавалось не целевое значения аргумента, а то поле
    // структуры, в которое должна была происходить запись значения.
    //dasmt_init(&t->das, opts->mapn, t->das.rnd);
    // Статический анализатор мог-бы предположить, запись вида 
    // t->das.rnd = t->das.rnd - подозрительна

    struct DAS {
        ...
        int                 mask_size;
        ...
    };
    for (int i = 0; i < das->map_size; i++) {
        for (int j = 0; j < das->map_size; j++) {
            //fprintf(fd, "%d", das->map_mask[i * das->mask_size + j]);
            // ошибочное использование похожей переменной ведет к падению программы
            fprintf(fd, "%d", das->map_mask[i * das->map_size + j]);
        }
        fprintf(fd, "\n");
    }
    Golloolo: чтобы такого не было надо было объекты сделать наверное у которых
    бы были уже поля размеров


Скорость компиляции за счет параллельной сборки нескольких модулей. Значит
должна быть какая-то особенность позволяющая начинать собирать модули 
параллельно. Первое, что приходит на ум - сборка без имен, с именами - 
заместителями.

Макро-язык

Объектно-ориентированная поддержка не в C++ стиле. Минусы - скорость работы.
Плюсы?

Если объекты - структуры с полями, то можно менять методы на лету.
Разница между методом и чистой функцией.
